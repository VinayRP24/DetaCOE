{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util'; // Utilities needed by backend consumers of tf-core.\n\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return x.clone();\n    }\n\n    var zerosTensor = zeros(x.shape);\n    var floatX = cast(x, 'float32');\n    var result = backend.complex(floatX, zerosTensor);\n    zerosTensor.dispose();\n    floatX.dispose();\n    return result;\n  }\n\n  if (!hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n  }\n\n  if (x.dtype === 'complex64') {\n    var real = backend.real(x);\n\n    var _result = cast(real, dtype);\n\n    real.dispose();\n    return _result;\n  }\n\n  if (dtype === 'int32') {\n    return backend.int(x);\n  } else if (dtype === 'bool') {\n    var zero = scalar(0, x.dtype);\n\n    var _result2 = backend.notEqual(x, zero);\n\n    zero.dispose();\n    return _result2;\n  } else {\n    throw new Error(\"Error in Cast: failed to cast \".concat(x.dtype, \" to \").concat(dtype));\n  }\n}\nexport function reshapeTensor(x, shape) {\n  return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n  try {\n    // Decode the bytes into string.\n    return vals.map(function (val) {\n      return decodeString(val);\n    });\n  } catch (err) {\n    throw new Error(\"Failed to decode encoded string bytes into utf-8, error: \".concat(err));\n  }\n}\nexport function fromStringArrayToUint8(strings) {\n  return strings.map(function (s) {\n    return encodeString(s);\n  });\n}","map":{"version":3,"sources":["../../src/backends/backend_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return x.clone();\n        }\n        const zerosTensor = zeros(x.shape);\n        const floatX = cast(x, 'float32');\n        const result = backend.complex(floatX, zerosTensor);\n        zerosTensor.dispose();\n        floatX.dispose();\n        return result;\n    }\n    if (!hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n    }\n    if (x.dtype === 'complex64') {\n        const real = backend.real(x);\n        const result = cast(real, dtype);\n        real.dispose();\n        return result;\n    }\n    if (dtype === 'int32') {\n        return backend.int(x);\n    }\n    else if (dtype === 'bool') {\n        const zero = scalar(0, x.dtype);\n        const result = backend.notEqual(x, zero);\n        zero.dispose();\n        return result;\n    }\n    else {\n        throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n    }\n}\nexport function reshapeTensor(x, shape) {\n    return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n    try {\n        // Decode the bytes into string.\n        return vals.map(val => decodeString(val));\n    }\n    catch (err) {\n        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n    }\n}\nexport function fromStringArrayToUint8(strings) {\n    return strings.map(s => encodeString(s));\n}\n//# sourceMappingURL=backend_util.js.map"]},"metadata":{},"sourceType":"module"}