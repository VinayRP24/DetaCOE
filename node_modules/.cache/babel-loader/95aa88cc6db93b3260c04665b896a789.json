{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util'; // Utilities needed by backend consumers of tf-core.\n\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return x.clone();\n    }\n\n    const zerosTensor = zeros(x.shape);\n    const floatX = cast(x, 'float32');\n    const result = backend.complex(floatX, zerosTensor);\n    zerosTensor.dispose();\n    floatX.dispose();\n    return result;\n  }\n\n  if (!hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n  }\n\n  if (x.dtype === 'complex64') {\n    const real = backend.real(x);\n    const result = cast(real, dtype);\n    real.dispose();\n    return result;\n  }\n\n  if (dtype === 'int32') {\n    return backend.int(x);\n  } else if (dtype === 'bool') {\n    const zero = scalar(0, x.dtype);\n    const result = backend.notEqual(x, zero);\n    zero.dispose();\n    return result;\n  } else {\n    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n  }\n}\nexport function reshapeTensor(x, shape) {\n  return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n  try {\n    // Decode the bytes into string.\n    return vals.map(val => decodeString(val));\n  } catch (err) {\n    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n  }\n}\nexport function fromStringArrayToUint8(strings) {\n  return strings.map(s => encodeString(s));\n}","map":{"version":3,"sources":["../../src/backends/backend_util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { cast } from '../ops/cast';\nimport { scalar } from '../ops/scalar';\nimport { zeros } from '../ops/zeros';\nimport { decodeString, encodeString, hasEncodingLoss } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function castTensor(x, dtype, backend) {\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return x.clone();\n        }\n        const zerosTensor = zeros(x.shape);\n        const floatX = cast(x, 'float32');\n        const result = backend.complex(floatX, zerosTensor);\n        zerosTensor.dispose();\n        floatX.dispose();\n        return result;\n    }\n    if (!hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);\n    }\n    if (x.dtype === 'complex64') {\n        const real = backend.real(x);\n        const result = cast(real, dtype);\n        real.dispose();\n        return result;\n    }\n    if (dtype === 'int32') {\n        return backend.int(x);\n    }\n    else if (dtype === 'bool') {\n        const zero = scalar(0, x.dtype);\n        const result = backend.notEqual(x, zero);\n        zero.dispose();\n        return result;\n    }\n    else {\n        throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n    }\n}\nexport function reshapeTensor(x, shape) {\n    return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);\n}\nexport function fromUint8ToStringArray(vals) {\n    try {\n        // Decode the bytes into string.\n        return vals.map(val => decodeString(val));\n    }\n    catch (err) {\n        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n    }\n}\nexport function fromStringArrayToUint8(strings) {\n    return strings.map(s => encodeString(s));\n}\n//# sourceMappingURL=backend_util.js.map"]},"metadata":{},"sourceType":"module"}